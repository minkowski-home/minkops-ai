# Decision Logs

### 03-02-2026
We created `docs/decisions-log.md` as the canonical place to store product briefs (new launches), onboarding playbooks, system design decisions, problems found and how they were fixed, architecture notes, and governance policies. When new cross-cutting decisions are made — for example, conventions for knowledge graphs, audit trails, or policy enforcement, or any major improvement/trade-off — we capture them in `docs/` so every module (apps, services, infra) can reference the same playbook, similar to a monorepo “engineering handbook”. There isn’t a strict schema beyond including the date; entries should be explanatory paragraphs that a junior engineer can use to understand senior trade-offs.


### 2026-02-04 
We consolidated duplicated agent-facing schema definitions (e.g., `Ticket`, `KBChunk`, `TenantProfile`) into a single, typing-only module at `agents/src/agents/shared/schemas.py`. Previously, identical concepts were redefined across `agents.shared.db`, `agents.shared.kb`, and the Imel agent’s `state.py`, which introduced drift (for example, `keywords` was typed as a string in one location and a list in another) and forced downstream code to use `typing.cast` to bridge mismatched types. We explicitly avoided importing these types from `agents.shared.db` or `agents.shared.kb` into agent state modules because those helpers carry heavier runtime dependencies (database drivers and optional KB/LLM dependencies), and coupling state definitions to them increases the chance of import-time failures in minimal environments and creates an undesirable layering inversion. Centralizing shared schemas in a pure-typing module keeps imports lightweight, prevents schema drift, and allows persistence/KB helpers and agent state to share a stable contract without circular dependencies or runtime coupling. As part of the change, we also added small normalization helpers in the KB loader to coerce potentially user-authored metadata into the canonical schema types.

### 2026-02-05
We removed `services/orchestrator` to eliminate a naming collision with the previously planned “Airflow orchestrator” (scheduler/manager) concept and to keep the repository’s layering unambiguous while the system is still small. `services/ai-suite` is now the single agent runtime orchestrator: it executes agent graphs from `agents/`, owns all operational side effects (Postgres reads/writes, outbox emission, inter-agent messaging, and external actions), and provides capability implementations grouped by domain rather than by agent. The `agents/` package remains a decisioning library plus contracts; agent `tools.py` files define Protocol-based capability requirements (verbs), `schemas.py` defines shared data shapes (nouns), and `state.py` defines per-run in-memory state, with concrete implementations living exclusively in the service layer. This capability-first runtime layout is intended to scale to many agents without per-agent infrastructure modules, while keeping the system explainable in interviews: “agents decide; the runtime executes and persists; shared capabilities are implemented once and reused everywhere.”

### 2026-02-06
We generalized the runtime execution contract so it no longer assumes every agent is email-centric. The previous `run_agent_once(...)` implementation had Imel-specific arguments (`email_id`, `sender_email`, `email_content`) and Imel-specific post-run behavior (send draft response email), which would not scale to heterogeneous agents. To fix this, we introduced an adapter layer (`services/ai-suite/ai_suite/runtime/adapters.py`) where each agent defines three concerns: payload validation/normalization, mapping payload into graph runner kwargs, and post-run effect handling. The core runner now accepts a generic `input_payload` dictionary and delegates agent-specific behavior to the adapter selected in the registry. This keeps the runtime stable as new agents are added and avoids centralizing agent-specific `if/else` logic in orchestration code. We also added a minimal but functional Kall agent path (`agents/general/kall`) that loads a ticket, resolves it, updates ticket status, and sends an inter-agent completion message, wired through the same generic runtime contract and CLI (`run-agent` plus `run-kall` convenience command). This preserves strict separation of concerns while proving that multiple agents with different trigger semantics can coexist without changing directory structure or rewriting core orchestrator flow.

### 2026-02-06 (LangGraph Standardization)
We upgraded both Imel and Kall to execute through compiled LangGraph workflows as the primary runtime path, instead of manual Python control flow. `run_imel(...)` and `run_kall(...)` now build their respective graphs and call `graph.invoke(...)`, while still exposing simple service-facing entrypoints for `ai-suite`. This keeps node logic unchanged and portable, but moves orchestration semantics (node graph, edges, `Command(goto=...)` routing, and thread execution config) into LangGraph where they belong. We also propagated the orchestrator `run_id` into agent runtime kwargs and use it as LangGraph `thread_id`, so runtime run records and graph execution traces share the same correlation key. This design gives us production-ready graph execution today while preserving the adapter/registry architecture for heterogeneous agents and future capabilities like durable checkpoints, resume/replay, and graph-level observability.
