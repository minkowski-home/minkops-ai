# Decision Logs

### 03-02-2026
We created `docs/decisions-log.md` as the canonical place to store product briefs (new launches), onboarding playbooks, system design decisions, problems found and how they were fixed, architecture notes, and governance policies. When new cross-cutting decisions are made — for example, conventions for knowledge graphs, audit trails, or policy enforcement, or any major improvement/trade-off — we capture them in `docs/` so every module (apps, services, infra) can reference the same playbook, similar to a monorepo “engineering handbook”. There isn’t a strict schema beyond including the date; entries should be explanatory paragraphs that a junior engineer can use to understand senior trade-offs.


### 2026-02-04 
We consolidated duplicated agent-facing schema definitions (e.g., `Ticket`, `KBChunk`, `TenantProfile`) into a single, typing-only module at `agents/src/agents/shared/schemas.py`. Previously, identical concepts were redefined across `agents.shared.db`, `agents.shared.kb`, and the Imel agent’s `state.py`, which introduced drift (for example, `keywords` was typed as a string in one location and a list in another) and forced downstream code to use `typing.cast` to bridge mismatched types. We explicitly avoided importing these types from `agents.shared.db` or `agents.shared.kb` into agent state modules because those helpers carry heavier runtime dependencies (database drivers and optional KB/LLM dependencies), and coupling state definitions to them increases the chance of import-time failures in minimal environments and creates an undesirable layering inversion. Centralizing shared schemas in a pure-typing module keeps imports lightweight, prevents schema drift, and allows persistence/KB helpers and agent state to share a stable contract without circular dependencies or runtime coupling. As part of the change, we also added small normalization helpers in the KB loader to coerce potentially user-authored metadata into the canonical schema types.

### 2026-02-05
We removed `services/orchestrator` to eliminate a naming collision with the previously planned “Airflow orchestrator” (scheduler/manager) concept and to keep the repository’s layering unambiguous while the system is still small. `services/ai-suite` is now the single agent runtime orchestrator: it executes agent graphs from `agents/`, owns all operational side effects (Postgres reads/writes, outbox emission, inter-agent messaging, and external actions), and provides capability implementations grouped by domain rather than by agent. The `agents/` package remains a decisioning library plus contracts; agent `tools.py` files define Protocol-based capability requirements (verbs), `schemas.py` defines shared data shapes (nouns), and `state.py` defines per-run in-memory state, with concrete implementations living exclusively in the service layer. This capability-first runtime layout is intended to scale to many agents without per-agent infrastructure modules, while keeping the system explainable in interviews: “agents decide; the runtime executes and persists; shared capabilities are implemented once and reused everywhere.”
