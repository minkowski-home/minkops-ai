# Decision Logs

### 03-02-2026
We created `docs/decisions-log.md` as the canonical place to store product briefs (new launches), onboarding playbooks, system design decisions, problems found and how they were fixed, architecture notes, and governance policies. When new cross-cutting decisions are made — for example, conventions for knowledge graphs, audit trails, or policy enforcement, or any major improvement/trade-off — we capture them in `docs/` so every module (apps, services, infra) can reference the same playbook, similar to a monorepo “engineering handbook”. There isn’t a strict schema beyond including the date; entries should be explanatory paragraphs that a junior engineer can use to understand senior trade-offs.


### 2026-02-04 
We consolidated duplicated agent-facing schema definitions (e.g., `Ticket`, `KBChunk`, `TenantProfile`) into a single, typing-only module at `agents/src/agents/shared/schemas.py`. Previously, identical concepts were redefined across `agents.shared.db`, `agents.shared.kb`, and the Imel agent’s `state.py`, which introduced drift (for example, `keywords` was typed as a string in one location and a list in another) and forced downstream code to use `typing.cast` to bridge mismatched types. We explicitly avoided importing these types from `agents.shared.db` or `agents.shared.kb` into agent state modules because those helpers carry heavier runtime dependencies (database drivers and optional KB/LLM dependencies), and coupling state definitions to them increases the chance of import-time failures in minimal environments and creates an undesirable layering inversion. Centralizing shared schemas in a pure-typing module keeps imports lightweight, prevents schema drift, and allows persistence/KB helpers and agent state to share a stable contract without circular dependencies or runtime coupling. As part of the change, we also added small normalization helpers in the KB loader to coerce potentially user-authored metadata into the canonical schema types.

### 2026-02-05
We removed `services/orchestrator` to eliminate a naming collision with the previously planned “Airflow orchestrator” (scheduler/manager) concept and to keep the repository’s layering unambiguous while the system is still small. `services/ai-suite` is now the single agent runtime orchestrator: it executes agent graphs from `agents/`, owns all operational side effects (Postgres reads/writes, outbox emission, inter-agent messaging, and external actions), and provides capability implementations grouped by domain rather than by agent. The `agents/` package remains a decisioning library plus contracts; agent `tools.py` files define Protocol-based capability requirements (verbs), `schemas.py` defines shared data shapes (nouns), and `state.py` defines per-run in-memory state, with concrete implementations living exclusively in the service layer. This capability-first runtime layout is intended to scale to many agents without per-agent infrastructure modules, while keeping the system explainable in interviews: “agents decide; the runtime executes and persists; shared capabilities are implemented once and reused everywhere.”

### 2026-02-06
We generalized the runtime execution contract so it no longer assumes every agent is email-centric. The previous `run_agent_once(...)` implementation had Imel-specific arguments (`email_id`, `sender_email`, `email_content`) and Imel-specific post-run behavior (send draft response email), which would not scale to heterogeneous agents. To fix this, we introduced an adapter layer (`services/ai-suite/ai_suite/runtime/adapters.py`) where each agent defines three concerns: payload validation/normalization, mapping payload into graph runner kwargs, and post-run effect handling. The core runner now accepts a generic `input_payload` dictionary and delegates agent-specific behavior to the adapter selected in the registry. This keeps the runtime stable as new agents are added and avoids centralizing agent-specific `if/else` logic in orchestration code. We also added a minimal but functional Kall agent path (`agents/general/kall`) that loads a ticket, resolves it, updates ticket status, and sends an inter-agent completion message, wired through the same generic runtime contract and CLI (`run-agent` plus `run-kall` convenience command). This preserves strict separation of concerns while proving that multiple agents with different trigger semantics can coexist without changing directory structure or rewriting core orchestrator flow.

### 2026-02-06 (LangGraph Standardization)
We upgraded both Imel and Kall to execute through compiled LangGraph workflows as the primary runtime path, instead of manual Python control flow. `run_imel(...)` and `run_kall(...)` now build their respective graphs and call `graph.invoke(...)`, while still exposing simple service-facing entrypoints for `ai-suite`. This keeps node logic unchanged and portable, but moves orchestration semantics (node graph, edges, `Command(goto=...)` routing, and thread execution config) into LangGraph where they belong. We also propagated the orchestrator `run_id` into agent runtime kwargs and use it as LangGraph `thread_id`, so runtime run records and graph execution traces share the same correlation key. This design gives us production-ready graph execution today while preserving the adapter/registry architecture for heterogeneous agents and future capabilities like durable checkpoints, resume/replay, and graph-level observability.

### 2026-02-08
We hardened local runtime bootstrap to handle realistic developer environments where the Postgres role can create databases but cannot create the `vector` extension. Previously, `seed-db` failed early at `CREATE EXTENSION vector`, which blocked tenant provisioning and then caused follow-on runtime failures (`runs.tenant_id` foreign key violations) because the tenant seed step never ran. We changed `db/init_agents_db.sql` to attempt extension creation with an explicit fallback path and to create `tenant_kb_chunks` with either a `vector` column (preferred) or a `JSONB` embedding fallback when pgvector is unavailable. We also updated the seeding code to detect which column shape exists and insert accordingly, preserving a single CLI flow without requiring superuser privileges in local development while keeping the production path vector-native.

During the same recovery pass we fixed two additional boot blockers discovered while validating the full CLI flow end-to-end. First, `seed-db` defaults (`db/init_agents_db.sql` and `data/...`) were relative to repository root but often executed from `services/ai-suite`; we added deterministic path resolution so defaults now work from either location. Second, the schema used `messages.current_role`, which is a problematic reserved identifier in this context; we replaced it with `messages.role` so database creation is stable. After unblocking bootstrap, `run-imel` surfaced a separate runtime issue where `_classify_email` and `_draft_reply` were referenced but undefined; we restored these helper paths with robust deterministic fallbacks and guarded LLM parsing, so the graph now executes both without `--use-llm` and with model responses. The validated result is a successful sequence of `seed-db`, `run-imel`, and `run-kall` in local shell execution.

### Database Design
#### `tenant_id` doesn't reference the tenants table

  This is a deliberate architectural choice, not an oversight. The outbox is infrastructure — it's a durable delivery mechanism that needs to function even in degraded states. If tenant_id had a foreign key to tenants, then deleting or disabling a tenant would either cascade-delete pending outbox events (losing in-flight work) or block the tenant deletion entirely due to the constraint. Neither is acceptable behavior for an outbox.
  More broadly, the outbox is append-only operational infrastructure. It doesn't need referential integrity to tenants to do its job — the tenant_id there is purely for partitioning and filtering work by tenant, not for enforcing relational correctness. The same reasoning applies to activity_logs, which your schema comments already acknowledge explicitly. 
